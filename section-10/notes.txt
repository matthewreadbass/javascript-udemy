A Closer Look At Functions

Default Parameters

    Sometimes useful to have default parameters incase no parameters are passed in
        const aFunction = function (param1 = 100, param2 = 'default') {
            console.log(param1, param2);
        }
            |=> afunction(); => 100, 'default'
            |=> aFunction(1); => 1, 'default'
            |=> aFunction(1, 7); => 1, 7
    Otherwise parameters are undefined
    Can use values of previous input values to assign defaults
        const anotherFunction = function (param1, param2 = param1 * 2) {
            console.log(param1, param2);
        }
            |=> anotherFunction(35); => 35, 70
            |=> anotherFunction(35, 36); => 35, 36
    Skip an argument by setting it as undefined
        aFunction(undefined, 'cheese'); => 100, 'cheese'

First-Class and High-Order Functions

    First-Class functions:
        JS treats functions as first-class citizens
        This means that functions a simply values
        Functions are just another 'type' of object
            Store functions in variables of properties
            Pass functions as arguments to OTHER functions
            Return functions FROM functions
            Call methods on functions
    
    Higher-Order functions:
        A function that receives another function as an argument, that returns a function or both
        This is only possible because of first-class functions

Functions Accepting Callback Functions

    Enables us to split up our code in to more re-usable/inter-connected parts
    Allow us to create abstraction
        - Hide the detail of problems, so that they can be viewed from a more higher-level, more abstract perspective
    High-level/low-level are to do with the level of abstraction