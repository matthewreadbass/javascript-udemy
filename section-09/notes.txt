Destructuring Arrays

    Destructuring
        - An ES6 feature
        - Unpacking values from an array/object in to seperate variables
        - Breaking a complex data structure down in to a smaller data structure (variable)

    Without destructuring
        const arr = [2, 3, 4];
        const a = arr[0]; => 2
        const b = arr[1]; => 3
        const c = arr[2]; => 4

    With destructuring
        const arr = [2, 3, 4];
        const [x, y, z] = arr;
        console.log(x); => will log 2
        console.log(y); => will log 3
        console.log(z); => will log 4

Destructuring Objects

    Same concept as with arrays
    Have to use exact property names to extract variables from the object
    
        const matthew = {
            name: "Matthew",
            age: 27,
            job: "Software Engineer",
        };

        const { name, age, job } = matthew;
        console.log(name); => will log "Matthew"
        console.log(age); => will log 27
        console.log(job); => will log "Software Engineer"

    If you want different variable names from original property names

        const { name: whatTheyIsCalled, age: howOldTheyIs, job: whatTheyDoesForALiving } = matthew;
        console.log(whatTheyIsCalled); => will log "Matthew"
        console.log(howOldTheyIs); => will log 27
        console.log(whatTheyDoesForALiving); => will log "Software Engineer"

The Spread Operator (...)

    Expand an array in to all of it's elements
    Unpack all array elements at once
    Written on the RH side of the assignment operator (=)
    Only able to use it in places where you would write values seperated by commas (not objects)
        - Doesn't create new variables
    Use to create shallow copies of arrays and merge two arrays together
        const arrCopy = [...arr];
        const combinedArr = [...arr1, ...arr2];
    Spread Operator works on all iterables
        Iterable: arrays, strings, maps, sets
            Not objects (not strictly true)
        You can use iterables on all of above
            const string = 'string';
            const letters = [...string];
            console.log(letters); => ['s', 't', 'r', 'i', 'n', 'g']
        
        Since ES2018, the Spread operator now works on objects too!
            const newObject = {...object, newInformation, coolStuff};

Rest pattern and parameters

    Exact same syntax as spread operator
    Used to collect individual elements and condense them in to an array
    Takes the REST of the elements and makes a new array out of them
    Must be the last element in a destructuring assignment
        Can only ever be one rest in a destructuring assignment
    Written on the LH side of the assignment operator (=)
        const [ a, b, ...others ] = [1, 2, 3, 4, 5];
            |=> a = 1, b = 2, others = [3, 4, 5]
    Also works with objects
        Elements can't be skipped as objects aren't indexed
            const { 3, 4, ...others } = numbers;
            console.log(3); => { 3: 'three' }
            console.log(4); => { 4: 'four' }
            console.log(others); => { 1: 'one', 2: 'two', 5: 'five' }
    Can be used in function arguments

Short Circuiting (&& and ||)

    AND (&&) and OR (||) operators can be used for more than just with boolean values
        3 || 'Matthew' => 3
        0 && 'Matthew' => 0
    Logical Operators can:
        - use any data type
        - return any data type
        - perform short-circuit evaluation
    
    Short Circuiting with the || operator
        If the first value is a truthy value, it will return that value
            'hello' || 'cheese' => 'hello'
            false || 'cheese' => 'cheese'
        If more than two values present, the first truthy value will be returned

    Short Circuiting with the && operator
        Will return the first falsey value
            false && true => false
            'hello' && 'world' && 54 & undefined => undefined
        Will return the last value if all values are true
            12 && 'hello' => 'hello'

The Nullish Coalescing Operator (??)

    Introduced in ES2020
    Solves the issue of 0 being considered falsey when short circuiting with || and &&
        const zero = 0
        const zeroOrTen = zero || 10; => 10
            Fix using...
        const zeroOrTenNCO = zero ?? 10; => 0
    The Nullish Coalescing Operator works with the concept of nullish values, rather than falsey values
    Nullish values === null or undefined
        |=> DOES NOT include 0 or ''

Logical Assignment Operators

    Logical OR Assignment Operator
        Works similarly to += / -= exact
            reduce...
                this = this || that;
            to...
                this ||= that;
    As with short circuiting, doesn't work with 0 as it is considered falsey

    Logical Nullish Assignment Operator
        Same concept as the Nullish Coalescing Operator
            const this = 0;
            const that = 10;
            this ||= that; => 10
            this ??= that; => 0
    
    Logical AND Assignment Operator
        Replaces values if they exist
            this.number = 10;
            this.number &&= 15; => changes the value from 10 to 15
            this.word &&= 'hello'; => this.word does not exist and so nothing is evaluated
            console.log(this.word); => undefined

Looping Arrays - The for-of Loop

    Instead of setting up a for loop with a counter/condition 
    and updating the counter, use a for-of loop
        const nums = ['zero', 'one', 'two', 'three', 'four'];
        for (const num of nums) console.log(num);
            |=> 'zero'
            |=> 'one'
            |=> 'two'
            |=> 'three'
            |=> 'four'
    Can still use the continue & break keywords
    To access the index of each item
        for (const num of nums.entries()) {
            console.log(item);
        };
            |=> [0, 'zero'] // [indexPoistion, value]
            |=> [1, 'one']
            |=> [2, 'two']
            |=> [3, 'three']
            |=> [4, 'four']

Enhanced Object Literals

    Object Literal - An object written in using the {} syntax
        const object = {<some-stuff>};
        const otherObject = {<other-stuff>};

        instead of writing...
            otherObject: otherObject
        ... in object, simply write
            otherObject
    Write functions inside objects without the function keyword
        const object = {
            add(num1, num2) {
                return num1 + num2;
            }
        };
    Compute property names instead of having to write them out manually/literally
        ie. using array index positions/numeric calculations etc

Optional Chaining (?.)

    ES2020 Introduced
    If a certain property does not exist, undefined is returned immediately (instead of an error)
    Prevents having to use long, unnecesarry logic to test for the existance of things
    Used for deeply-nested objects with lots of optional properties
        object.method.questionableMethod?.finalMethod;
            |=> if .questionableMethod exists, .finalMethod will run
            |=> if not, will return undefined
    Chain multiple Optional Chaining operators
        object.method.questionableMethod?.questionableMethod2?.finalMethod;
            |=> will return undefined if either .questionableMethod doesn't exist on the object
    Can be used to check if a method exists before calling it
        object.method?.()
            |=> returns undefined if method does not exist
    Optional Chaining works on arrays, checking if they are empty
        const empty = [];
        const arr = [{value: 1}];
        empty[0]?.value ?? 'Array empty'; => 'Array empty'
        arr[0]?.value ?? 'Array empty'; => 1

Looping Objects: Object Keys, Values and Entries

    Different options, depending on what you want to loop over
    for Object.keys(<property-name>);
        |=> creates an array of all the different values associated to the specified property name