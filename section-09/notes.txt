Destructuring Arrays

    Destructuring
        - An ES6 feature
        - Unpacking values from an array/object in to seperate variables
        - Breaking a complex data structure down in to a smaller data structure (variable)

    Without destructuring
        const arr = [2, 3, 4];
        const a = arr[0]; => 2
        const b = arr[1]; => 3
        const c = arr[2]; => 4

    With destructuring
        const arr = [2, 3, 4];
        const [x, y, z] = arr;
        console.log(x); => will log 2
        console.log(y); => will log 3
        console.log(z); => will log 4

Destructuring Objects

    Same concept as with arrays
    Have to use exact property names to extract variables from the object
    
        const matthew = {
            name: "Matthew",
            age: 27,
            job: "Software Engineer",
        };

        const { name, age, job } = matthew;
        console.log(name); => will log "Matthew"
        console.log(age); => will log 27
        console.log(job); => will log "Software Engineer"

    If you want different variable names from original property names

        const { name: whatTheyIsCalled, age: howOldTheyIs, job: whatTheyDoesForALiving } = matthew;
        console.log(whatTheyIsCalled); => will log "Matthew"
        console.log(howOldTheyIs); => will log 27
        console.log(whatTheyDoesForALiving); => will log "Software Engineer"

The Spread Operator (...)

    Expand an array in to all of it's elements
    Unpack all array elements at once
    Written on the RH side of the assignment operator (=)
    Only able to use it in places where you would write values seperated by commas (not objects)
        - Doesn't create new variables
    Use to create shallow copies of arrays and merge two arrays together
        const arrCopy = [...arr];
        const combinedArr = [...arr1, ...arr2];
    Spread Operator works on all iterables
        Iterable: arrays, strings, maps, sets
            Not objects (not strictly true)
        You can use iterables on all of above
            const string = 'string';
            const letters = [...string];
            console.log(letters); => ['s', 't', 'r', 'i', 'n', 'g']
        
        Since ES2018, the Spread operator now works on objects too!
            const newObject = {...object, newInformation, coolStuff};

Rest pattern and parameters

    Exact same syntax as spread operator
    Used to collect individual elements and condense them in to an array
    Takes the REST of the elements and makes a new array out of them
    Must be the last element in a destructuring assignment
        Can only ever be one rest in a destructuring assignment
    Written on the LH side of the assignment operator (=)
        const [ a, b, ...others ] = [1, 2, 3, 4, 5];
            |=> a = 1, b = 2, others = [3, 4, 5]
    Also works with objects
        Elements can't be skipped as objects aren't indexed
            const { 3, 4, ...others } = numbers;
            console.log(3); => { 3: 'three' }
            console.log(4); => { 4: 'four' }
            console.log(others); => { 1: 'one', 2: 'two', 5: 'five' }
    Can be used in function arguments

Short Circuiting (&& and ||)

    AND (&&) and OR (||) operators can be used for more than just with boolean values
        3 || 'Matthew' => 3
        0 && 'Matthew' => 0
    Logical Operators can:
        - use any data type
        - return any data type
        - perform short-circuit evaluation
    
    Short Circuiting with the || operator
        If the first value is a truthy value, it will return that value
            'hello' || 'cheese' => 'hello'
            false || 'cheese' => 'cheese'
        If more than two values present, the first truthy value will be returned

    Short Circuiting with the && operator
        Will return the first falsey value
            false && true => false
            'hello' && 'world' && 54 & undefined => undefined
        Will return the last value if all values are true
            12 && 'hello' => 'hello'

The Nullish Coalescing Operator (??)

    Introduced in ES2020
    Solves the issue of 0 being considered falsey when short circuiting with || and &&
        const zero = 0
        const zeroOrTen = zero || 10; => 10
            Fix using...
        const zeroOrTenNCO = zero ?? 10; => 0
    The Nullish Coalescing Operator works with the concept of nullish values, rather than falsey values
    Nullish values === null or undefined
        |=> DOES NOT include 0 or ''
